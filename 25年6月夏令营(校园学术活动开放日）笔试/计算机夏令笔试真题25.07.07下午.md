**第三次（2025-09-08）**

![image-20250908221157447](C:\Users\63213\AppData\Roaming\Typora\typora-user-images\image-20250908221157447.png)

```
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

#ifdef LOCAL
#include "algo/debug.h"
#else
#define dbg(...) "jzz2.0"
#define debug(...) "jzz2.0"
#endif

#define int LL
#define endl "\n"
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define all1(x) (x).begin() + 1, (x).end()

const int N = 2e5 + 10;
vector<int> a;

int dfs(int l, int r) {
	// return -1 单调
	// return > 0 拐点
	
	if (r - l + 1 == 2) {
		return -1;
	}
	if (r - l + 1 == 3) {
		int mid = l + r >> 1;
		if (a[l] < a[mid] && a[mid] < a[r]) {
			return -1;
		}
		if (a[l] > a[mid] && a[mid] > a[r]) {
			return -1;
		}
		return mid;
	}
	
	int mid = l + r >> 1;
	int lc = dfs(l, mid);
	int rc = dfs(mid + 1, r);
	
	if (lc != -1 || rc != -1) {
		return max(lc, rc);
	}
	return a[mid] < a[mid + 1] ? mid : mid + 1;
}

signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	int n;
	cin >> n;
	a = vector<int> (n + 1);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	dbg(a);
	
	int ans1 = -1;
	for (int i = 2; i < n; i++) {
		if (a[i - 1] > a[i] && a[i] < a[i + 1]) {
			ans1 = i;
		}
	}
	// O(n)
	debug(ans1);
	
	int p = dfs(1, n);
	// O(n) // 2^0 + 2^1 + ... + 2^(k - 1) = 2^k - 1
	
	cout << p << endl;
	
	int l = 2, r = n - 1; // [l, r]
	p = -1;
	while (l <= r) {
		int mid = l + r >> 1;
		if (a[mid - 1] > a[mid]) {
			l = mid + 1;
			p = mid;
		} else {
			r = mid - 1;
		}
	}
	// O(log(n))
	
	cout << p << endl;
	return 0 ^ 0;
}
```

![image-20250908230100761](C:\Users\63213\AppData\Roaming\Typora\typora-user-images\image-20250908230100761.png)

```
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

#ifdef LOCAL
#include "algo/debug.h"
#else
#define dbg(...) "jzz2.0"
#define debug(...) "jzz2.0"
#endif

#define int LL
#define endl "\n"
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define all1(x) (x).begin() + 1, (x).end()

signed main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	int n, d;
	cin >> n >> d;
	vector<array<int, 2>> p(n + 1);
	for (int i = 1; i <= n; i++) {
		cin >> p[i][0] >> p[i][1];
	}
	
	sort(p.begin() + 1, p.end(), [&](array<int, 2> x, array<int, 2> y) {
		if (x[0] == y[0]) return x[1] < y[1];
		return x[0] < y[0];
	});
	
	// for (int i = 1; i <= n; i++) {
	// 	cout << p[i][0] << " " << p[i][1] << endl;
	// }
	
	vector<int> PreMax(n + 1); // PreMax[i] = max(f[1], f[2], ..., f[i])
	
	vector<int> f(n + 1); // f[i] 表示当选了点i时，此时前缀中能选出的y之和，最大是多少
	for (int i = 1, j = 1; i <= n; i++) {
		auto [x, y] = p[i];
		f[i] = y;
		while (p[j + 1][0] + d <= p[i][0]) {
			j += 1;
		}
		// x[j] + d < x[i]
		f[i] += PreMax[j];
		
		PreMax[i] = max(PreMax[i - 1], f[i]);
	}
	// O(n)
	dbg(f);
	
	cout << *max_element(f.begin(), f.end()) << endl;
	
	int ans = 0;
	vector<int> st(n + 1); // 0/1
	auto dfs = [&](auto dfs, int u) -> void {
		if (u == n + 1) {
			int pos = -1, sumY = 0;
			for (int i = 1; i <= n; i++) {
				if (st[i] == 1) {
					if (pos != -1 && p[i][0] - p[pos][0] < d) {
						return ;
					}
					pos = i;
					sumY += p[i][1];
				}
			}
			ans = max(ans, sumY);
			return;
		}
		
		for (int i = 0; i < 2; i++) {
			st[u] = i;
			dfs(dfs, u + 1);
		}
	};
	dfs(dfs, 1);
	// O(2^n)
	
	cout << ans << endl;
	return 0 ^ 0;
}
```

